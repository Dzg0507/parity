
on: push: branches: [ "main" ] pull_request: branches: [ "main" ]

jobs: lint-and-test: name: Lint and Unit Test runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4

  - name: Setup Node.js v18
    uses: actions/setup-node@v4
    with:
      node-version: 18
      cache: 'yarn'

  - name: Install dependencies
    run: yarn install --frozen-lockfile

  - name: Run ESLint
    run: yarn lint

  - name: Run unit tests
    run: yarn test
build-android: name: Build Android needs: lint-and-test runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4

  - name: Setup Node.js v18
    uses: actions/setup-node@v4
    with:
      node-version: 18
      cache: 'yarn'

  - name: Setup Java (JDK 11)
    uses: actions/setup-java@v4
    with:
      distribution: 'temurin'
      java-version: '11'

  - name: Install dependencies
    run: yarn install --frozen-lockfile

  - name: Create google-services.json
    run: echo '${{ secrets.GOOGLE_SERVICES_JSON }}' > android/app/google-services.json
    env:
      GOOGLE_SERVICES_JSON: ${{ secrets.GOOGLE_SERVICES_JSON }}

  - name: Setup Gradle
    uses: gradle/gradle-build-action@v2

  - name: Make gradlew executable
    run: chmod +x ./android/gradlew

  - name: Build Android Release APK
    run: cd android && ./gradlew assembleRelease
    # For a real build, you would need to configure signing keys
    # env:
    #   SIGNING_KEY_ALIAS: ${{ secrets.SIGNING_KEY_ALIAS }}
    #   SIGNING_KEY_PASSWORD: ${{ secrets.SIGNING_KEY_PASSWORD }}
    #   SIGNING_STORE_PASSWORD: ${{ secrets.SIGNING_STORE_PASSWORD }}
    #   ENCODED_SIGNING_KEY: ${{ secrets.ENCODED_SIGNING_KEY }}
build-ios: name: Build iOS needs: lint-and-test runs-on: macos-latest steps: - name: Checkout repository uses: actions/checkout@v4

  - name: Setup Node.js v18
    uses: actions/setup-node@v4
    with:
      node-version: 18
      cache: 'yarn'

  - name: Install dependencies
    run: yarn install --frozen-lockfile

  - name: Create GoogleService-Info.plist
    run: echo '${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}' > ios/Parity/GoogleService-Info.plist
    env:
      GOOGLE_SERVICE_INFO_PLIST: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST }}

  - name: Install CocoaPods
    run: gem install cocoapods

  - name: Install Pods
    run: cd ios && pod install

  - name: Build iOS App
    run: |
      cd ios
      xcodebuild -workspace Parity.xcworkspace                  -scheme Parity                  -sdk iphoneos                  -configuration Release                  CODE_SIGN_IDENTITY=""                  CODE_SIGNING_REQUIRED=NO                  build
    # Note: A real build for TestFlight/App Store would require
    # installing certificates and provisioning profiles using secrets.
    # This step only validates that the project builds successfully. An expert backend developer would approach this task by selecting a robust and scalable technology stack that aligns with the needs of a modern mobile application. Given the features, a Node.js server with the Express framework, using MongoDB as the database, is an excellent choice. This stack is JavaScript-based, aligning with the React Native frontend, and provides the flexibility needed for the diverse data structures described.
Here is the complete backend application, built with Node.js, Express, and Mongoose.